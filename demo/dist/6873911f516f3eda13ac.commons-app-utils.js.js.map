{"version":3,"file":"6873911f516f3eda13ac.commons-app-utils.js.js","mappings":"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","sources":["webpack:///../node_modules/batch-processor/src/utils.js","webpack:///../node_modules/immutablediff/src/utils.js","webpack:///../node_modules/react-range/lib/utils.js"],"sourcesContent":["\"use strict\";\n\nvar utils = module.exports = {};\n\nutils.getOption = getOption;\n\nfunction getOption(options, name, defaultValue) {\n    var value = options[name];\n\n    if((value === undefined || value === null) && defaultValue !== undefined) {\n        return defaultValue;\n    }\n\n    return value;\n}\n","'use strict';\n\nvar Immutable = require('immutable');\n\nvar isMap = function(obj){ return Immutable.Iterable.isKeyed(obj); };\nvar isIndexed = function(obj) { return Immutable.Iterable.isIndexed(obj); };\n\nvar op = function(operation, path, value){\n  if(operation === 'remove') { return { op: operation, path: path }; }\n\n  return { op: operation, path: path, value: value };\n};\n\nmodule.exports = {\n  isMap: isMap,\n  isIndexed: isIndexed,\n  op: op\n};","\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = require(\"react\");\nvar types_1 = require(\"./types\");\nvar getStepDecimals = function (step) {\n    var decimals = step.toString().split('.')[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return ((event.touches && event.touches.length) ||\n        (event.changedTouches && event.changedTouches.length));\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value)\n            return prev;\n        if (next && next < value)\n            return next;\n    }\n    if (value > max)\n        return max;\n    if (value < min)\n        return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) %\n        Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2\n        ? rounded\n        : rounded + step;\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    }\n    else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2)\n        return;\n    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {\n        throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['margin-top'], 10),\n        bottom: parseInt(style['margin-bottom'], 10),\n        left: parseInt(style['margin-left'], 10),\n        right: parseInt(style['margin-right'], 10)\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['padding-top'], 10) + parseInt(style['border-top-width'], 10),\n        bottom: parseInt(style['padding-bottom'], 10) + parseInt(style['border-bottom-width'], 10),\n        left: parseInt(style['padding-left'], 10) + parseInt(style['border-left-width'], 10),\n        right: parseInt(style['padding-right'], 10) + parseInt(style['border-right-width'], 10),\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function (element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for (var i = 1; i < thumbs.length; i++) {\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function (fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function () {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    }\n    else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values.slice(0).sort(function (a, b) { return a - b; }).map(function (value) { return ((value - min) / (max - min)) * 100; });\n    var middle = progress.reduce(function (acc, point, index) {\n        return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n    }, '');\n    return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() { }\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var width = Math.ceil(__spreadArray([thumbEl], Array.from(thumbEl.children), true).reduce(function (width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */\n        if (el.innerText &&\n            el.innerText.includes(separator) &&\n            el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = 'hidden';\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */\n    var buildOverlaps = function (thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */\n        offsets.forEach(function (_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex &&\n                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||\n                    (thumbX + thumbXWidth >= siblingX &&\n                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArray(__spreadArray([], overlaps, true), [thumbIndex, siblingIndex], false);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nvar useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) { step = 0.1; }\n    if (separator === void 0) { separator = ' - '; }\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = (0, react_1.useState)({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    (0, react_1.useEffect)(function () {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1)\n                return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */\n            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */\n            if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */\n                var offsetsX = overlaps.reduce(function (a, c, i, s) {\n                    return a.length ? __spreadArray(__spreadArray([], a, true), [offsets_1[s[i]].x], false) : [offsets_1[s[i]].x];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */\n                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */\n                    var labelValues_1 = [];\n                    overlaps.forEach(function (thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */\n                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))\n                        .map(valueToLabel)\n                        .join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */\n                    var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n                    newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n                    newStyle.transform = 'translate(-50%, 0)';\n                }\n                else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = 'hidden';\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [rangeRef, values]);\n    return [labelValue, labelStyle];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction) ? Math.abs(clientY - (top + height / 2)) : Math.abs(clientX - (left + width / 2));\n}\n"],"names":["module","exports","getOption","options","name","defaultValue","value","undefined","Immutable","isMap","obj","Iterable","isKeyed","isIndexed","op","operation","path","__spreadArray","this","to","from","pack","arguments","length","ar","i","l","Array","prototype","slice","call","concat","Object","defineProperty","useThumbOverlap","assertUnreachable","voidFn","getTrackBackground","replaceAt","schd","translate","getClosestThumbIndex","translateThumbs","getPaddingAndBorder","getMargin","checkInitialOverlap","checkValuesAgainstBoundaries","checkBoundaries","isVertical","relativeValue","normalizeValue","isStepDivisible","isTouchEvent","getStepDecimals","react_1","types_1","direction","Direction","Up","Down","element","x","y","style","transform","step","decimals","toString","split","event","touches","changedTouches","min","max","roundedRes","Number","toFixed","parseInt","index","allowOverlap","values","BIG_NUM","Math","round","prev","next","remainder","floor","closestLowerNum","abs","rounded","res","decimalPlaces","parseFloat","RangeError","every","item","window","getComputedStyle","top","bottom","left","right","elements","offsets","rtl","inverter","forEach","thumbs","clientX","clientY","thumbIndex","minThumbDistance","getThumbDistance","thumbDistance","fn","lastArgs","frameId","args","_i","requestAnimationFrame","apply","ret","_a","colors","_b","Right","_c","Left","middle","sort","a","b","map","reduce","acc","point","Error","getThumbWidth","thumbEl","separator","valueToLabel","ceil","children","width","el","elWidth","getBoundingClientRect","innerText","includes","childElementCount","elClone","cloneNode","innerHTML","visibility","document","body","appendChild","removeChild","height","rangeRef","useState","labelStyle","setLabelStyle","labelValue","setLabelValue","useEffect","getThumbs","newStyle","offsets_1","getOffsets","overlaps","buildOverlaps","thumbXWidth","thumbX","siblingIndex","siblingX","siblingWidth","push","Set","getOverlaps","labelValue_1","offsetsX","c","s","labelValues_1","thumb","join","first","last","lastWidth","indexOf"],"sourceRoot":""}